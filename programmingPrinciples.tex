\chapter{Programming Principles}
\section{SOLID}
\paragraph{Single responsibility principle}
Die meisten Klassen in der Anwendung erfüllen das Prinzip. Eine Klasse welches es allerdings nicht erfüllt hat, ist der \textit{MainWindowController}. Dieser war zum einen der Adapter zwischen dem \textit{MainWindow} und dem \textit{GameManager} hat aber auch das verbinden von Buchstaben in der GUI kontrolliert. Die Funktionalitäten zum Verbinden von Buchstaben wurde daher in eine Neue Klasse \textit{WordBuilder} ausgelagert, Commit \href{https://github.com/EinToni/Wortfinder/commit/817e4b1b6be02defe58792a4afb709c7a147ced5}{817e4b1b6be02defe58792a4afb709c7a147ced5} und der darauf folgende. 


\paragraph{Open/Closed principle}
Eine auffällige Verbesserungsmöglichkeit wurde im \textit{GameScoreCalculator} gefunden, welcher immer wieder modifiziert wurde um die Punktzahl anders zu berechnen. Die Berechnung wurde nun Erweiterbar ausgelagert. Dafür wurde eine Liste im \textit{GameScoreCalculator} erstellt welche Klassen eines \textit{IPointFactor} Interfaces beinhaltet. Über diese wird beim Berechnen der Punkte Iteriert und jede Klasse berechnet dann einen Teilbetrag der Punktzahl, bezogen auf einen bestimmten Faktor. Siehe Commit \href{https://github.com/EinToni/Wortfinder/commit/6a4834cfc653a63ed3efc8745bccbe603250da74}{6a4834cfc653a63ed3efc8745bccbe603250da74}.


\paragraph{Liskov substitution principle}
Da keine Vererbung verwendet wird, ist das Liskov substitution principle erfüllt.

\paragraph{Dependency inversion principle}
Dependency inversion wurde im Rahmen der Implementierung der Clean Architecture an allen Grenzen der einzelnen Schichten angewendet.

\section{GRASP}
\paragraph{Grundkonzept} Der Code hat stellenweise eine recht hohe Kopplung, da oft Funktionen innerhalb der selben Klasse aufgerufen werden. Oftmals ist die Kopplung aber auch niedrig, weil für viele Klassen Interfaces verwendet und diese aufgerufen werden. Die Kohäsion ist vor allem im Domain und Application code recht hoch.


\paragraph{Code-Strukturierung}
Es wird viel Indirection verwendet. Ein gutes Beispiel dafür ist der \textit{GameManager}, welcher im Grunde alle aufrufe an verschiedene andere Klassen weiterleitet.


\paragraph{Architektur}
\glqq Pure fabrication\grqq{} findet sich in der \textit{EnDecoder} Klasse wieder. Diese ist unabhängig von jeglicher Anwendungslogik und ver- bzw. entschlüsselt einen beliebigen Stream mit einem beliebigen key in ein beliebiges Verzeichnis.


\paragraph{Entwurfsmuster}
Die GUI kommuniziert immer nur mit einen Controller. Ein Beispiel ist der \textit{MainWindowController}. Dieser Leitet die Aufrufe weiter und wandelt teilweise Datentypen um.


\section{DRY}
Das \glqq don't repeat yourself\grqq{} Prinzip wurde im Produktivcode meistens eingehalten, da die Informationen als Klassen Parameter gespeichert und wiederverwendet wurden. Somit ist die Information nur an einem Ort gespeichert. Innerhalb von Tests wurde das Prinzip allerdings häufig nicht eingehalten. Weil die Tests oft schnell geschrieben wurden, wurden meistens keine extra Variablen angelegt, sondern die Informationen mehrfach geschrieben. Die Anpassungen der Tests sind in Commit \href{https://github.com/EinToni/Wortfinder/commit/31e056a85512623173a8e4efa2faa828b2f66466}{31e056a85512623173a8e4efa2faa828b2f66466}.
\endinput